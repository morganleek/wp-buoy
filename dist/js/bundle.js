/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/google-charts/dist/googleCharts.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/google-charts/dist/googleCharts.esm.js ***!
  \*************************************************************/
/*! exports provided: default, GoogleCharts */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GoogleCharts\", function() { return GoogleCharts; });\n/* googleCharts.js Version: 1.5.0 Built On: 2018-12-30 */\nconst loadScript = Symbol('loadScript');\nconst instance = Symbol('instance');\n\nlet _instance;\n\nclass GoogleChartsManager {\n  get [instance]() {\n    return _instance;\n  }\n\n  set [instance](value) {\n    _instance = value;\n  }\n\n  constructor() {\n    if (this[instance]) {\n      return this[instance];\n    }\n\n    this[instance] = this;\n  }\n\n  reset() {\n    _instance = null;\n  }\n\n  [loadScript]() {\n    if (!this.scriptPromise) {\n      this.scriptPromise = new Promise(resolve => {\n        const body = document.getElementsByTagName('body')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n\n        script.onload = function () {\n          GoogleCharts.api = window.google;\n          GoogleCharts.api.charts.load('current', {\n            packages: ['corechart', 'table']\n          });\n          GoogleCharts.api.charts.setOnLoadCallback(() => {\n            resolve();\n          });\n        };\n\n        script.src = 'https://www.gstatic.com/charts/loader.js';\n        body.appendChild(script);\n      });\n    }\n\n    return this.scriptPromise;\n  }\n\n  load(callback, type) {\n    return this[loadScript]().then(() => {\n      if (type) {\n        let config = {};\n\n        if (type instanceof Object) {\n          config = type;\n        } else if (Array.isArray(type)) {\n          config = {\n            packages: type\n          };\n        } else {\n          config = {\n            packages: [type]\n          };\n        }\n\n        this.api.charts.load('current', config);\n        this.api.charts.setOnLoadCallback(callback);\n      } else {\n        if (typeof callback != 'function') {\n          throw 'callback must be a function';\n        } else {\n          callback();\n        }\n      }\n    });\n  }\n\n}\n\nconst GoogleCharts = new GoogleChartsManager();\n/* harmony default export */ __webpack_exports__[\"default\"] = (GoogleChartsManager);\n\n\n//# sourceURL=webpack:///./node_modules/google-charts/dist/googleCharts.esm.js?");

/***/ }),

/***/ "./node_modules/load-google-maps-api/index.js":
/*!****************************************************!*\
  !*** ./node_modules/load-google-maps-api/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const API_URL = 'https://maps.googleapis.com/maps/api/js';\nconst CALLBACK_NAME = '__googleMapsApiOnLoadCallback';\nconst optionsKeys = ['channel', 'client', 'key', 'language', 'region', 'v'];\nlet promise = null;\n\nmodule.exports = function (options = {}) {\n  promise = promise || new Promise(function (resolve, reject) {\n    // Reject the promise after a timeout\n    const timeoutId = setTimeout(function () {\n      window[CALLBACK_NAME] = function () {}; // Set the on load callback to a no-op\n\n\n      reject(new Error('Could not load the Google Maps API'));\n    }, options.timeout || 10000); // Hook up the on load callback\n\n    window[CALLBACK_NAME] = function () {\n      if (timeoutId !== null) {\n        clearTimeout(timeoutId);\n      }\n\n      resolve(window.google.maps);\n      delete window[CALLBACK_NAME];\n    }; // Prepare the `script` tag to be inserted into the page\n\n\n    const scriptElement = document.createElement('script');\n    const params = [`callback=${CALLBACK_NAME}`];\n    optionsKeys.forEach(function (key) {\n      if (options[key]) {\n        params.push(`${key}=${options[key]}`);\n      }\n    });\n\n    if (options.libraries && options.libraries.length) {\n      params.push(`libraries=${options.libraries.join(',')}`);\n    }\n\n    scriptElement.src = `${options.apiUrl || API_URL}?${params.join('&')}`; // Insert the `script` tag\n\n    document.body.appendChild(scriptElement);\n  });\n  return promise;\n};\n\n//# sourceURL=webpack:///./node_modules/load-google-maps-api/index.js?");

/***/ }),

/***/ "./node_modules/markerwithlabel/index.js":
/*!***********************************************!*\
  !*** ./node_modules/markerwithlabel/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @name MarkerWithLabel for V3\n * @version 1.1.9 [June 30, 2013]\n * @author Gary Little (inspired by code from Marc Ridey of Google).\n * @copyright Copyright 2012 Gary Little [gary at luxcentral.com]\n * @fileoverview MarkerWithLabel extends the Google Maps JavaScript API V3\n *  <code>google.maps.Marker</code> class.\n *  <p>\n *  MarkerWithLabel allows you to define markers with associated labels. As you would expect,\n *  if the marker is draggable, so too will be the label. In addition, a marker with a label\n *  responds to all mouse events in the same manner as a regular marker. It also fires mouse\n *  events and \"property changed\" events just as a regular marker would. Version 1.1 adds\n *  support for the raiseOnDrag feature introduced in API V3.3.\n *  <p>\n *  If you drag a marker by its label, you can cancel the drag and return the marker to its\n *  original position by pressing the <code>Esc</code> key. This doesn't work if you drag the marker\n *  itself because this feature is not (yet) supported in the <code>google.maps.Marker</code> class.\n */\n\n/*!\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*jslint browser:true */\n\n/*global document,google */\n\n/**\n * @param {Function} childCtor Child class.\n * @param {Function} parentCtor Parent class.\n */\nfunction inherits(childCtor, parentCtor) {\n  /** @constructor */\n  function tempCtor() {}\n\n  ;\n  tempCtor.prototype = parentCtor.prototype;\n  childCtor.superClass_ = parentCtor.prototype;\n  childCtor.prototype = new tempCtor();\n  /** @override */\n\n  childCtor.prototype.constructor = childCtor;\n}\n/**\n * @param {Object} gMapsApi The Google Maps API instance (usually `google.maps`)\n * @return {Function} The instantiable MarkerWithLabel class\n */\n\n\nmodule.exports = function (gMapsApi) {\n  /**\n   * This constructor creates a label and associates it with a marker.\n   * It is for the private use of the MarkerWithLabel class.\n   * @constructor\n   * @param {Marker} marker The marker with which the label is to be associated.\n   * @param {string} crossURL The URL of the cross image =.\n   * @param {string} handCursor The URL of the hand cursor.\n   * @private\n   */\n  function MarkerLabel_(marker, crossURL, handCursorURL) {\n    this.marker_ = marker;\n    this.handCursorURL_ = marker.handCursorURL;\n    this.labelDiv_ = document.createElement(\"div\");\n    this.labelDiv_.style.cssText = \"position: absolute; overflow: hidden;\"; // Set up the DIV for handling mouse events in the label. This DIV forms a transparent veil\n    // in the \"overlayMouseTarget\" pane, a veil that covers just the label. This is done so that\n    // events can be captured even if the label is in the shadow of a google.maps.InfoWindow.\n    // Code is included here to ensure the veil is always exactly the same size as the label.\n\n    this.eventDiv_ = document.createElement(\"div\");\n    this.eventDiv_.style.cssText = this.labelDiv_.style.cssText; // This is needed for proper behavior on MSIE:\n\n    this.eventDiv_.addEventListener('selectstart', function () {\n      return false;\n    });\n    this.eventDiv_.addEventListener('dragstart', function () {\n      return false;\n    }); // Get the DIV for the \"X\" to be displayed when the marker is raised.\n\n    this.crossDiv_ = MarkerLabel_.getSharedCross(crossURL);\n  }\n\n  inherits(MarkerLabel_, gMapsApi.OverlayView);\n  /**\n   * Returns the DIV for the cross used when dragging a marker when the\n   * raiseOnDrag parameter set to true. One cross is shared with all markers.\n   * @param {string} crossURL The URL of the cross image =.\n   * @private\n   */\n\n  MarkerLabel_.getSharedCross = function (crossURL) {\n    var div;\n\n    if (typeof MarkerLabel_.getSharedCross.crossDiv === \"undefined\") {\n      div = document.createElement(\"img\");\n      div.style.cssText = \"position: absolute; z-index: 1000002; display: none;\"; // Hopefully Google never changes the standard \"X\" attributes:\n\n      div.style.marginLeft = \"-8px\";\n      div.style.marginTop = \"-9px\";\n      div.src = crossURL;\n      MarkerLabel_.getSharedCross.crossDiv = div;\n    }\n\n    return MarkerLabel_.getSharedCross.crossDiv;\n  };\n  /**\n   * Adds the DIV representing the label to the DOM. This method is called\n   * automatically when the marker's <code>setMap</code> method is called.\n   * @private\n   */\n\n\n  MarkerLabel_.prototype.onAdd = function () {\n    var me = this;\n    var cMouseIsDown = false;\n    var cDraggingLabel = false;\n    var cSavedZIndex;\n    var cLatOffset, cLngOffset;\n    var cIgnoreClick;\n    var cRaiseEnabled;\n    var cStartPosition;\n    var cStartCenter; // Constants:\n\n    var cRaiseOffset = 20;\n    var cDraggingCursor = \"url(\" + this.handCursorURL_ + \")\"; // Stops all processing of an event.\n    //\n\n    var cAbortEvent = function (e) {\n      if (e.preventDefault) {\n        e.preventDefault();\n      }\n\n      e.cancelBubble = true;\n\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      }\n    };\n\n    var cStopBounce = function () {\n      me.marker_.setAnimation(null);\n    };\n\n    this.getPanes().markerLayer.appendChild(this.labelDiv_);\n    this.getPanes().overlayMouseTarget.appendChild(this.eventDiv_); // One cross is shared with all markers, so only add it once:\n\n    if (typeof MarkerLabel_.getSharedCross.processed === \"undefined\") {\n      this.getPanes().markerLayer.appendChild(this.crossDiv_);\n      MarkerLabel_.getSharedCross.processed = true;\n    }\n\n    this.listeners_ = [gMapsApi.event.addDomListener(this.eventDiv_, \"mouseover\", function (e) {\n      if (me.marker_.getDraggable() || me.marker_.getClickable()) {\n        this.style.cursor = \"pointer\";\n        gMapsApi.event.trigger(me.marker_, \"mouseover\", e);\n      }\n    }), gMapsApi.event.addDomListener(this.eventDiv_, \"mouseout\", function (e) {\n      if ((me.marker_.getDraggable() || me.marker_.getClickable()) && !cDraggingLabel) {\n        this.style.cursor = me.marker_.getCursor();\n        gMapsApi.event.trigger(me.marker_, \"mouseout\", e);\n      }\n    }), gMapsApi.event.addDomListener(this.eventDiv_, \"mousedown\", function (e) {\n      cDraggingLabel = false;\n\n      if (me.marker_.getDraggable()) {\n        cMouseIsDown = true;\n        this.style.cursor = cDraggingCursor;\n      }\n\n      if (me.marker_.getDraggable() || me.marker_.getClickable()) {\n        gMapsApi.event.trigger(me.marker_, \"mousedown\", e);\n        cAbortEvent(e); // Prevent map pan when starting a drag on a label\n      }\n    }), gMapsApi.event.addDomListener(document, \"mouseup\", function (mEvent) {\n      var position;\n\n      if (cMouseIsDown) {\n        cMouseIsDown = false;\n        me.eventDiv_.style.cursor = \"pointer\";\n        gMapsApi.event.trigger(me.marker_, \"mouseup\", mEvent);\n      }\n\n      if (cDraggingLabel) {\n        if (cRaiseEnabled) {\n          // Lower the marker & label\n          position = me.getProjection().fromLatLngToDivPixel(me.marker_.getPosition());\n          position.y += cRaiseOffset;\n          me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position)); // This is not the same bouncing style as when the marker portion is dragged,\n          // but it will have to do:\n\n          try {\n            // Will fail if running Google Maps API earlier than V3.3\n            me.marker_.setAnimation(gMapsApi.Animation.BOUNCE);\n            setTimeout(cStopBounce, 1406);\n          } catch (e) {}\n        }\n\n        me.crossDiv_.style.display = \"none\";\n        me.marker_.setZIndex(cSavedZIndex);\n        cIgnoreClick = true; // Set flag to ignore the click event reported after a label drag\n\n        cDraggingLabel = false;\n        mEvent.latLng = me.marker_.getPosition();\n        gMapsApi.event.trigger(me.marker_, \"dragend\", mEvent);\n      }\n    }), gMapsApi.event.addListener(me.marker_.getMap(), \"mousemove\", function (mEvent) {\n      var position;\n\n      if (cMouseIsDown) {\n        if (cDraggingLabel) {\n          // Change the reported location from the mouse position to the marker position:\n          mEvent.latLng = new gMapsApi.LatLng(mEvent.latLng.lat() - cLatOffset, mEvent.latLng.lng() - cLngOffset);\n          position = me.getProjection().fromLatLngToDivPixel(mEvent.latLng);\n\n          if (cRaiseEnabled) {\n            me.crossDiv_.style.left = position.x + \"px\";\n            me.crossDiv_.style.top = position.y + \"px\";\n            me.crossDiv_.style.display = \"\";\n            position.y -= cRaiseOffset;\n          }\n\n          me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));\n\n          if (cRaiseEnabled) {\n            // Don't raise the veil; this hack needed to make MSIE act properly\n            me.eventDiv_.style.top = position.y + cRaiseOffset + \"px\";\n          }\n\n          gMapsApi.event.trigger(me.marker_, \"drag\", mEvent);\n        } else {\n          // Calculate offsets from the click point to the marker position:\n          cLatOffset = mEvent.latLng.lat() - me.marker_.getPosition().lat();\n          cLngOffset = mEvent.latLng.lng() - me.marker_.getPosition().lng();\n          cSavedZIndex = me.marker_.getZIndex();\n          cStartPosition = me.marker_.getPosition();\n          cStartCenter = me.marker_.getMap().getCenter();\n          cRaiseEnabled = me.marker_.get(\"raiseOnDrag\");\n          cDraggingLabel = true;\n          me.marker_.setZIndex(1000000); // Moves the marker & label to the foreground during a drag\n\n          mEvent.latLng = me.marker_.getPosition();\n          gMapsApi.event.trigger(me.marker_, \"dragstart\", mEvent);\n        }\n      }\n    }), gMapsApi.event.addDomListener(document, \"keydown\", function (e) {\n      if (cDraggingLabel) {\n        if (e.keyCode === 27) {\n          // Esc key\n          cRaiseEnabled = false;\n          me.marker_.setPosition(cStartPosition);\n          me.marker_.getMap().setCenter(cStartCenter);\n          gMapsApi.event.trigger(document, \"mouseup\", e);\n        }\n      }\n    }), gMapsApi.event.addDomListener(this.eventDiv_, \"click\", function (e) {\n      if (me.marker_.getDraggable() || me.marker_.getClickable()) {\n        if (cIgnoreClick) {\n          // Ignore the click reported when a label drag ends\n          cIgnoreClick = false;\n        } else {\n          gMapsApi.event.trigger(me.marker_, \"click\", e);\n          cAbortEvent(e); // Prevent click from being passed on to map\n        }\n      }\n    }), gMapsApi.event.addDomListener(this.eventDiv_, \"dblclick\", function (e) {\n      if (me.marker_.getDraggable() || me.marker_.getClickable()) {\n        gMapsApi.event.trigger(me.marker_, \"dblclick\", e);\n        cAbortEvent(e); // Prevent map zoom when double-clicking on a label\n      }\n    }), gMapsApi.event.addListener(this.marker_, \"dragstart\", function (mEvent) {\n      if (!cDraggingLabel) {\n        cRaiseEnabled = this.get(\"raiseOnDrag\");\n      }\n    }), gMapsApi.event.addListener(this.marker_, \"drag\", function (mEvent) {\n      if (!cDraggingLabel) {\n        if (cRaiseEnabled) {\n          me.setPosition(cRaiseOffset); // During a drag, the marker's z-index is temporarily set to 1000000 to\n          // ensure it appears above all other markers. Also set the label's z-index\n          // to 1000000 (plus or minus 1 depending on whether the label is supposed\n          // to be above or below the marker).\n\n          me.labelDiv_.style.zIndex = 1000000 + (this.get(\"labelInBackground\") ? -1 : +1);\n        }\n      }\n    }), gMapsApi.event.addListener(this.marker_, \"dragend\", function (mEvent) {\n      if (!cDraggingLabel) {\n        if (cRaiseEnabled) {\n          me.setPosition(0); // Also restores z-index of label\n        }\n      }\n    }), gMapsApi.event.addListener(this.marker_, \"position_changed\", function () {\n      me.setPosition();\n    }), gMapsApi.event.addListener(this.marker_, \"zindex_changed\", function () {\n      me.setZIndex();\n    }), gMapsApi.event.addListener(this.marker_, \"visible_changed\", function () {\n      me.setVisible();\n    }), gMapsApi.event.addListener(this.marker_, \"labelvisible_changed\", function () {\n      me.setVisible();\n    }), gMapsApi.event.addListener(this.marker_, \"title_changed\", function () {\n      me.setTitle();\n    }), gMapsApi.event.addListener(this.marker_, \"labelcontent_changed\", function () {\n      me.setContent();\n    }), gMapsApi.event.addListener(this.marker_, \"labelanchor_changed\", function () {\n      me.setAnchor();\n    }), gMapsApi.event.addListener(this.marker_, \"labelclass_changed\", function () {\n      me.setStyles();\n    }), gMapsApi.event.addListener(this.marker_, \"labelstyle_changed\", function () {\n      me.setStyles();\n    })];\n  };\n  /**\n   * Removes the DIV for the label from the DOM. It also removes all event handlers.\n   * This method is called automatically when the marker's <code>setMap(null)</code>\n   * method is called.\n   * @private\n   */\n\n\n  MarkerLabel_.prototype.onRemove = function () {\n    var i;\n\n    if (this.labelDiv_.parentNode) {\n      this.labelDiv_.parentNode.removeChild(this.labelDiv_);\n      this.eventDiv_.parentNode.removeChild(this.eventDiv_);\n    } // Remove event listeners:\n\n\n    if (this.listeners_) {\n      for (i = 0; i < this.listeners_.length; i++) {\n        gMapsApi.event.removeListener(this.listeners_[i]);\n      }\n    }\n  };\n  /**\n   * Draws the label on the map.\n   * @private\n   */\n\n\n  MarkerLabel_.prototype.draw = function () {\n    this.setContent();\n    this.setTitle();\n    this.setStyles();\n  };\n  /**\n   * Sets the content of the label.\n   * The content can be plain text or an HTML DOM node.\n   * @private\n   */\n\n\n  MarkerLabel_.prototype.setContent = function () {\n    var content = this.marker_.get(\"labelContent\");\n\n    if (typeof content.nodeType === \"undefined\") {\n      this.labelDiv_.innerHTML = content;\n      this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;\n    } else {\n      // Remove current content\n      while (this.labelDiv_.lastChild) {\n        this.labelDiv_.removeChild(this.labelDiv_.lastChild);\n      }\n\n      while (this.eventDiv_.lastChild) {\n        this.eventDiv_.removeChild(this.eventDiv_.lastChild);\n      }\n\n      this.labelDiv_.appendChild(content);\n      content = content.cloneNode(true);\n      this.eventDiv_.appendChild(content);\n    }\n  };\n  /**\n   * Sets the content of the tool tip for the label. It is\n   * always set to be the same as for the marker itself.\n   * @private\n   */\n\n\n  MarkerLabel_.prototype.setTitle = function () {\n    this.eventDiv_.title = this.marker_.getTitle() || \"\";\n  };\n  /**\n   * Sets the style of the label by setting the style sheet and applying\n   * other specific styles requested.\n   * @private\n   */\n\n\n  MarkerLabel_.prototype.setStyles = function () {\n    var i, labelStyle; // Apply style values from the style sheet defined in the labelClass parameter:\n\n    this.labelDiv_.className = this.marker_.get(\"labelClass\");\n    this.eventDiv_.className = this.labelDiv_.className; // Clear existing inline style values:\n\n    this.labelDiv_.style.cssText = \"\";\n    this.eventDiv_.style.cssText = \"\"; // Apply style values defined in the labelStyle parameter:\n\n    labelStyle = this.marker_.get(\"labelStyle\");\n\n    for (i in labelStyle) {\n      if (labelStyle.hasOwnProperty(i)) {\n        this.labelDiv_.style[i] = labelStyle[i];\n        this.eventDiv_.style[i] = labelStyle[i];\n      }\n    }\n\n    this.setMandatoryStyles();\n  };\n  /**\n   * Sets the mandatory styles to the DIV representing the label as well as to the\n   * associated event DIV. This includes setting the DIV position, z-index, and visibility.\n   * @private\n   */\n\n\n  MarkerLabel_.prototype.setMandatoryStyles = function () {\n    this.labelDiv_.style.position = \"absolute\";\n    this.labelDiv_.style.overflow = \"hidden\"; // Make sure the opacity setting causes the desired effect on MSIE:\n\n    if (typeof this.labelDiv_.style.opacity !== \"undefined\" && this.labelDiv_.style.opacity !== \"\") {\n      this.labelDiv_.style.MsFilter = \"\\\"progid:DXImageTransform.Microsoft.Alpha(opacity=\" + this.labelDiv_.style.opacity * 100 + \")\\\"\";\n      this.labelDiv_.style.filter = \"alpha(opacity=\" + this.labelDiv_.style.opacity * 100 + \")\";\n    }\n\n    this.eventDiv_.style.position = this.labelDiv_.style.position;\n    this.eventDiv_.style.overflow = this.labelDiv_.style.overflow;\n    this.eventDiv_.style.opacity = 0.01; // Don't use 0; DIV won't be clickable on MSIE\n\n    this.eventDiv_.style.MsFilter = \"\\\"progid:DXImageTransform.Microsoft.Alpha(opacity=1)\\\"\";\n    this.eventDiv_.style.filter = \"alpha(opacity=1)\"; // For MSIE\n\n    this.setAnchor();\n    this.setPosition(); // This also updates z-index, if necessary.\n\n    this.setVisible();\n  };\n  /**\n   * Sets the anchor point of the label.\n   * @private\n   */\n\n\n  MarkerLabel_.prototype.setAnchor = function () {\n    var anchor = this.marker_.get(\"labelAnchor\");\n    this.labelDiv_.style.marginLeft = -anchor.x + \"px\";\n    this.labelDiv_.style.marginTop = -anchor.y + \"px\";\n    this.eventDiv_.style.marginLeft = -anchor.x + \"px\";\n    this.eventDiv_.style.marginTop = -anchor.y + \"px\";\n  };\n  /**\n   * Sets the position of the label. The z-index is also updated, if necessary.\n   * @private\n   */\n\n\n  MarkerLabel_.prototype.setPosition = function (yOffset) {\n    var position = this.getProjection().fromLatLngToDivPixel(this.marker_.getPosition());\n\n    if (typeof yOffset === \"undefined\") {\n      yOffset = 0;\n    }\n\n    this.labelDiv_.style.left = Math.round(position.x) + \"px\";\n    this.labelDiv_.style.top = Math.round(position.y - yOffset) + \"px\";\n    this.eventDiv_.style.left = this.labelDiv_.style.left;\n    this.eventDiv_.style.top = this.labelDiv_.style.top;\n    this.setZIndex();\n  };\n  /**\n   * Sets the z-index of the label. If the marker's z-index property has not been defined, the z-index\n   * of the label is set to the vertical coordinate of the label. This is in keeping with the default\n   * stacking order for Google Maps: markers to the south are in front of markers to the north.\n   * @private\n   */\n\n\n  MarkerLabel_.prototype.setZIndex = function () {\n    var zAdjust = this.marker_.get(\"labelInBackground\") ? -1 : +1;\n\n    if (typeof this.marker_.getZIndex() === \"undefined\") {\n      this.labelDiv_.style.zIndex = parseInt(this.labelDiv_.style.top, 10) + zAdjust;\n      this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;\n    } else {\n      this.labelDiv_.style.zIndex = this.marker_.getZIndex() + zAdjust;\n      this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;\n    }\n  };\n  /**\n   * Sets the visibility of the label. The label is visible only if the marker itself is\n   * visible (i.e., its visible property is true) and the labelVisible property is true.\n   * @private\n   */\n\n\n  MarkerLabel_.prototype.setVisible = function () {\n    if (this.marker_.get(\"labelVisible\")) {\n      this.labelDiv_.style.display = this.marker_.getVisible() ? \"block\" : \"none\";\n    } else {\n      this.labelDiv_.style.display = \"none\";\n    }\n\n    this.eventDiv_.style.display = this.labelDiv_.style.display;\n  };\n  /**\n   * @name MarkerWithLabelOptions\n   * @class This class represents the optional parameter passed to the {@link MarkerWithLabel} constructor.\n   *  The properties available are the same as for <code>google.maps.Marker</code> with the addition\n   *  of the properties listed below. To change any of these additional properties after the labeled\n   *  marker has been created, call <code>google.maps.Marker.set(propertyName, propertyValue)</code>.\n   *  <p>\n   *  When any of these properties changes, a property changed event is fired. The names of these\n   *  events are derived from the name of the property and are of the form <code>propertyname_changed</code>.\n   *  For example, if the content of the label changes, a <code>labelcontent_changed</code> event\n   *  is fired.\n   *  <p>\n   * @property {string|Node} [labelContent] The content of the label (plain text or an HTML DOM node).\n   * @property {Point} [labelAnchor] By default, a label is drawn with its anchor point at (0,0) so\n   *  that its top left corner is positioned at the anchor point of the associated marker. Use this\n   *  property to change the anchor point of the label. For example, to center a 50px-wide label\n   *  beneath a marker, specify a <code>labelAnchor</code> of <code>google.maps.Point(25, 0)</code>.\n   *  (Note: x-values increase to the right and y-values increase to the top.)\n   * @property {string} [labelClass] The name of the CSS class defining the styles for the label.\n   *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,\n   *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and\n   *  <code>marginTop</code> are ignored; these styles are for internal use only.\n   * @property {Object} [labelStyle] An object literal whose properties define specific CSS\n   *  style values to be applied to the label. Style values defined here override those that may\n   *  be defined in the <code>labelClass</code> style sheet. If this property is changed after the\n   *  label has been created, all previously set styles (except those defined in the style sheet)\n   *  are removed from the label before the new style values are applied.\n   *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,\n   *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and\n   *  <code>marginTop</code> are ignored; these styles are for internal use only.\n   * @property {boolean} [labelInBackground] A flag indicating whether a label that overlaps its\n   *  associated marker should appear in the background (i.e., in a plane below the marker).\n   *  The default is <code>false</code>, which causes the label to appear in the foreground.\n   * @property {boolean} [labelVisible] A flag indicating whether the label is to be visible.\n   *  The default is <code>true</code>. Note that even if <code>labelVisible</code> is\n   *  <code>true</code>, the label will <i>not</i> be visible unless the associated marker is also\n   *  visible (i.e., unless the marker's <code>visible</code> property is <code>true</code>).\n   * @property {boolean} [raiseOnDrag] A flag indicating whether the label and marker are to be\n   *  raised when the marker is dragged. The default is <code>true</code>. If a draggable marker is\n   *  being created and a version of Google Maps API earlier than V3.3 is being used, this property\n   *  must be set to <code>false</code>.\n   * @property {boolean} [optimized] A flag indicating whether rendering is to be optimized for the\n   *  marker. <b>Important: The optimized rendering technique is not supported by MarkerWithLabel,\n   *  so the value of this parameter is always forced to <code>false</code>.\n   * @property {string} [crossImage=\"http://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png\"]\n   *  The URL of the cross image to be displayed while dragging a marker.\n   * @property {string} [handCursor=\"http://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur\"]\n   *  The URL of the cursor to be displayed while dragging a marker.\n   */\n\n  /**\n   * Creates a MarkerWithLabel with the options specified in {@link MarkerWithLabelOptions}.\n   * @constructor\n   * @param {MarkerWithLabelOptions} [opt_options] The optional parameters.\n   */\n\n\n  function MarkerWithLabel(opt_options) {\n    opt_options = opt_options || {};\n    opt_options.labelContent = opt_options.labelContent || \"\";\n    opt_options.labelAnchor = opt_options.labelAnchor || new gMapsApi.Point(0, 0);\n    opt_options.labelClass = opt_options.labelClass || \"markerLabels\";\n    opt_options.labelStyle = opt_options.labelStyle || {};\n    opt_options.labelInBackground = opt_options.labelInBackground || false;\n\n    if (typeof opt_options.labelVisible === \"undefined\") {\n      opt_options.labelVisible = true;\n    }\n\n    if (typeof opt_options.raiseOnDrag === \"undefined\") {\n      opt_options.raiseOnDrag = true;\n    }\n\n    if (typeof opt_options.clickable === \"undefined\") {\n      opt_options.clickable = true;\n    }\n\n    if (typeof opt_options.draggable === \"undefined\") {\n      opt_options.draggable = false;\n    }\n\n    if (typeof opt_options.optimized === \"undefined\") {\n      opt_options.optimized = false;\n    }\n\n    opt_options.crossImage = opt_options.crossImage || \"http\" + (document.location.protocol === \"https:\" ? \"s\" : \"\") + \"://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png\";\n    opt_options.handCursor = opt_options.handCursor || \"http\" + (document.location.protocol === \"https:\" ? \"s\" : \"\") + \"://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur\";\n    opt_options.optimized = false; // Optimized rendering is not supported\n\n    this.label = new MarkerLabel_(this, opt_options.crossImage, opt_options.handCursor); // Bind the label to the marker\n    // Call the parent constructor. It calls Marker.setValues to initialize, so all\n    // the new parameters are conveniently saved and can be accessed with get/set.\n    // Marker.set triggers a property changed event (called \"propertyname_changed\")\n    // that the marker label listens for in order to react to state changes.\n\n    gMapsApi.Marker.apply(this, arguments);\n  }\n\n  inherits(MarkerWithLabel, gMapsApi.Marker);\n  /**\n   * Overrides the standard Marker setMap function.\n   * @param {Map} theMap The map to which the marker is to be added.\n   * @private\n   */\n\n  MarkerWithLabel.prototype.setMap = function (theMap) {\n    // Call the inherited function...\n    gMapsApi.Marker.prototype.setMap.apply(this, arguments); // ... then deal with the label:\n\n    this.label.setMap(theMap);\n  };\n\n  return MarkerWithLabel;\n};\n\n//# sourceURL=webpack:///./node_modules/markerwithlabel/index.js?");

/***/ }),

/***/ "./src/js/bundle.js":
/*!**************************!*\
  !*** ./src/js/bundle.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var google_charts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! google-charts */ \"./node_modules/google-charts/dist/googleCharts.esm.js\");\n/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules */ \"./src/js/modules/index.js\");\n\n\n // Charts\n\nvar chartsArray = []; // , dataPointsArray = [];\n\njquery__WEBPACK_IMPORTED_MODULE_0___default()(function () {\n  if (typeof google_charts__WEBPACK_IMPORTED_MODULE_1__[\"GoogleCharts\"] !== 'undefined') {\n    // get charts\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.ticks-chart').each(function () {\n      var $chart = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);\n      var $surround = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest('.chart-surround');\n      var id, buoyID, waveTickMax, waveTicks, peakTickMax, peakTicks, dataPoints;\n\n      if ($chart.attr('id') !== undefined) {\n        // chartsArray.push();\n        id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('id');\n        var $ticksData = $surround.find('.ticks-data');\n\n        if ($ticksData.length === 1) {\n          buoyID = $ticksData.attr('data-buoy-id') !== undefined ? $ticksData.attr('data-buoy-id') : '';\n          waveTickMax = $ticksData.attr('data-wave-tick-max') !== undefined ? $ticksData.attr('data-wave-tick-max') : '';\n          waveTicks = $ticksData.attr('data-wave-ticks') !== undefined ? $ticksData.attr('data-wave-ticks').split(',') : '';\n          peakTickMax = $ticksData.attr('data-peak-tick-max') !== undefined ? $ticksData.attr('data-peak-tick-max') : '';\n          peakTicks = $ticksData.attr('data-peak-ticks') !== undefined ? $ticksData.attr('data-peak-ticks').split(',') : '';\n          dataPoints = $ticksData.attr('data-data-points') !== undefined ? eval('[' + JSON.parse($ticksData.attr('data-data-points')) + ']') : '';\n        } // local time label\n\n\n        var offset = new Date().getTimezoneOffset() / 60 * -1; // hours from GMT\n\n        var timeLabel = offset === 0 ? \"Time (GMT)\" : offset > 0 ? \"Time (GMT+\" + offset + \")\" : \"Time (GMT\" + offset + \")\"; // push to chart array\n\n        if (id !== undefined && buoyID.length > 0 && waveTicks.length > 0 && waveTickMax.length > 0 && peakTicks.length > 0 && peakTickMax.length > 0 && dataPoints.length > 0) {\n          chartsArray.push({\n            id: id,\n            buoyID: buoyID,\n            dataPoints: dataPoints.slice(0, -1),\n            options: {\n              title: '',\n              height: 280,\n              backgroundColor: {\n                fill: \"transparent\"\n              },\n              // chartArea: {left: 45, top: 30, right: 45, bottom: 30},\n              series: {\n                0: {\n                  targetAxisIndex: 0,\n                  color: '#449d44',\n                  type: 'area'\n                },\n                1: {\n                  targetAxisIndex: 1,\n                  color: 'transparent',\n                  visibleInLegend: true\n                }\n              },\n              // hAxis: {\n              //   'title': timeLabel\n              // },\n              vAxes: {\n                0: {\n                  title: 'Wave Height (m)',\n                  viewWindow: {\n                    min: 0,\n                    max: waveTickMax\n                  },\n                  ticks: waveTicks\n                },\n                1: {\n                  title: 'Peak Period (s)',\n                  viewWindow: {\n                    min: 0,\n                    max: peakTickMax\n                  },\n                  ticks: peakTicks\n                }\n              },\n              hAxis: {\n                // 1: {\n                title: timeLabel,\n                interval: 1,\n                gridlines: {\n                  units: {\n                    days: {\n                      format: ['MMM d']\n                    },\n                    hours: {\n                      format: ['ha']\n                    }\n                  }\n                },\n                minorGridlines: {\n                  units: {\n                    hours: {\n                      format: ['ha']\n                    }\n                  }\n                } // }\n\n              }\n            }\n          });\n        }\n      }\n    }); // ES6 Load\n\n    google_charts__WEBPACK_IMPORTED_MODULE_1__[\"GoogleCharts\"].load(drawChart, {\n      'packages': ['line', 'corechart']\n    });\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('resize', function () {\n      drawChart();\n    });\n  }\n});\n\nfunction drawChart() {\n  if (typeof google_charts__WEBPACK_IMPORTED_MODULE_1__[\"GoogleCharts\"] !== 'undefined') {\n    if (chartsArray.length > 0) {\n      for (var i = 0; i < chartsArray.length; i++) {\n        // labels + chart data\n        var data = new google_charts__WEBPACK_IMPORTED_MODULE_1__[\"GoogleCharts\"].api.visualization.DataTable();\n        data.addColumn('date', 'Month');\n        data.addColumn('number', \"Significant Wave Height\");\n        data.addColumn({\n          type: 'string',\n          role: 'tooltip'\n        });\n        data.addColumn('number', \"Peak Period and Direction\");\n        data.addColumn({\n          type: 'string',\n          role: 'tooltip'\n        });\n        data.addRows(chartsArray[i].dataPoints);\n        var dataChart = new google_charts__WEBPACK_IMPORTED_MODULE_1__[\"GoogleCharts\"].api.visualization.LineChart(document.getElementById(chartsArray[i].id));\n        google_charts__WEBPACK_IMPORTED_MODULE_1__[\"GoogleCharts\"].api.visualization.events.addListener(dataChart, \"ready\", drawMarkers.bind(dataChart, chartsArray[i]));\n        dataChart.draw(data, chartsArray[i].options);\n      }\n    }\n  }\n}\n\nfunction drawMarkers(chartData) {\n  if (typeof google_charts__WEBPACK_IMPORTED_MODULE_1__[\"GoogleCharts\"] !== 'undefined') {\n    // interface\n    var cli = this.getChartLayoutInterface(); // for each chart\n\n    for (var i = 0; i < chartData.dataPoints.length; i++) {\n      var label = '.om-' + chartData.buoyID + '-overlay-marker-' + i;\n\n      if (document.querySelector(label) !== null) {\n        document.querySelector(label).style.top = Math.floor(cli.getYLocation(chartData.dataPoints[i][3], 1)) - 25 + \"px\";\n        document.querySelector(label).style.left = Math.floor(cli.getXLocation(chartData.dataPoints[i][0])) - 25 + \"px\";\n      }\n    } // Place Legend Marker\n\n\n    document.querySelector('.om-' + chartData.buoyID + '-legend-marker').style.top = Math.floor(cli.getBoundingBox(\"legendentry#1\").top) - 8 + \"px\";\n    document.querySelector('.om-' + chartData.buoyID + '-legend-marker').style.left = Math.floor(cli.getBoundingBox(\"legendentry#1\").left) + 4 + \"px\";\n  }\n}\n\n//# sourceURL=webpack:///./src/js/bundle.js?");

/***/ }),

/***/ "./src/js/modules/index.js":
/*!*********************************!*\
  !*** ./src/js/modules/index.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ \"./src/js/modules/map/index.js\");\n // import './chart';\n\n//# sourceURL=webpack:///./src/js/modules/index.js?");

/***/ }),

/***/ "./src/js/modules/map/index.js":
/*!*************************************!*\
  !*** ./src/js/modules/map/index.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n // Google Maps\n\nvar loadGoogleMapsApi = __webpack_require__(/*! load-google-maps-api */ \"./node_modules/load-google-maps-api/index.js\");\n\nvar map;\njquery__WEBPACK_IMPORTED_MODULE_0___default()(function () {\n  if (ajax_object.google_maps_api_key) {\n    // Maps\n    if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('#map').length > 0) {\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()('#map').each(function () {\n        var _this = this;\n\n        loadGoogleMapsApi({\n          key: ajax_object.google_maps_api_key\n        }).then(function (googleMaps) {\n          // Labels\n          var MarkerWithLabel = __webpack_require__(/*! markerwithlabel */ \"./node_modules/markerwithlabel/index.js\")(googleMaps);\n\n          var lat = parseFloat(ajax_object.starting_lat);\n          var lng = parseFloat(ajax_object.starting_lng);\n          var zoom = jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).width() < 1200 ? 4 : 5;\n          var latLng = {\n            lat: lat,\n            lng: lng\n          };\n          map = new googleMaps.Map(_this, {\n            center: latLng,\n            zoom: zoom,\n            // styles: mapStyle,\n            disableDefaultUI: true\n          }); // Set markers\n\n          for (var i = 0; i < global_points.length; i++) {\n            var marker = global_points[i].length >= 8 ? global_points[i][7] : \"0\";\n            var opacity = 1 - parseInt(marker) * 0.35;\n            var icon = {\n              url: ajax_object.plugin_url + 'dist/images/map-marker-' + marker + '-128.png',\n              scaledSize: {\n                width: 32,\n                height: 32\n              }\n            };\n            var point = new MarkerWithLabel({\n              position: {\n                lat: parseFloat(global_points[i][2]),\n                lng: parseFloat(global_points[i][3])\n              },\n              map: map,\n              title: global_points[i][6],\n              labelContent: global_points[i][5],\n              labelAnchor: new googleMaps.Point(0, -2),\n              labelClass: \"maps-label\",\n              // the CSS class for the label\n              labelStyle: {\n                opacity: 0.9\n              },\n              icon: icon,\n              opacity: opacity\n            });\n          }\n        })[\"catch\"](function (e) {\n          console.error(e);\n        });\n      });\n    } // Centre Map Buttons\n\n\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.map-focus').on('click', function (e) {\n      var dataBuoy = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest('.chart-js-layout').attr('data-buoy');\n      var lat = 0,\n          lng = 0;\n\n      for (var i = 0; i <= global_points_object.length; i++) {\n        if (global_points_object[i].buoy_id == dataBuoy) {\n          lat = parseFloat(global_points_object[i].lat);\n          lng = parseFloat(global_points_object[i].lng); // Set Centre and Zoom\n\n          map.setCenter({\n            lat: lat,\n            lng: lng\n          });\n          map.setZoom(12);\n          break;\n        }\n      }\n    });\n  } // var map;\n  // function initMap() {\n  // \tif(document.getElementById('map') !== null) {\n  // \t\tmap = new google.maps.Map(document.getElementById('map'), {\n  // \t\t  center: {lat: parseFloat(ajax_object.starting_lat), lng: parseFloat(ajax_object.starting_lng)},\n  // \t\t  zoom: ($(window).width() < 1200) ? 4 : 5\n  // \t\t});\n  // \t\t/*\n  // \t\t** Markers \n  // \t\t*/\n  // \t\t// Global Pointers\n  // \t\tfor(var i = 0; i < global_points.length; i++) {\n  // \t\t\tvar point = new MarkerWithLabel({\n  // \t\t\t\tposition: {lat: parseFloat(global_points[i][2]), lng: parseFloat(global_points[i][3])},\n  // \t\t\t\t// draggable: true,\n  // \t\t\t\t// raiseOnDrag: true,\n  // \t\t\t\tmap: map,\n  // \t\t\t\ttitle: global_points[i][6],\n  // \t\t\t\tlabelContent: global_points[i][5],\n  // \t\t\t\tlabelAnchor: new google.maps.Point(0, -2),\n  // \t\t\t\tlabelClass: \"maps-label\", // the CSS class for the label\n  // \t\t\t\tlabelStyle: {opacity: 0.9}\n  // \t\t\t});\n  // \t\t\tpoint.addListener('click', function() {\n  // \t\t\t\twindow.location = this.getTitle();\n  // \t\t\t});\n  // \t\t}\n  // \t}\n  // }\n  // $.when( $.ready ).then(function() {\n  // \tinitMap();\n  // });\n\n});\n\n//# sourceURL=webpack:///./src/js/modules/map/index.js?");

/***/ }),

/***/ 0:
/*!********************************!*\
  !*** multi ./src/js/bundle.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! /var/www/dea/wp-content/plugins/wp-buoy/src/js/bundle.js */\"./src/js/bundle.js\");\n\n\n//# sourceURL=webpack:///multi_./src/js/bundle.js?");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = jQuery;\n\n//# sourceURL=webpack:///external_%22jQuery%22?");

/***/ })

/******/ });